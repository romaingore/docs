---
title: "Multi-stage Builds"
description: "Optimiser la taille des images Docker avec les multi-stage builds"
---

Les **multi-stage builds** permettent de reduire drastiquement la taille des images Docker en separant la phase de **build** de la phase de **runtime**. Le resultat : des images de production legeres, securisees et rapides a deployer.

## Le probleme : images trop lourdes

Un Dockerfile classique pour une application Node.js/TypeScript produit une image de **1.2 GB** :

```
┌────────────────────────────────────────────┐
│           Image classique: ~1.2 GB          │
├────────────────────────────────────────────┤
│  Image de base node:20         ~300 MB      │
│  node_modules (dev + prod)     ~600 MB      │
│  Outils de build (tsc, webpack) ~200 MB     │
│  Code source                    ~50 MB      │
│  Application buildee            ~50 MB      │
└────────────────────────────────────────────┘
```

<Warning>
En production, on n'a besoin **QUE** de l'application buildee et de ses dependances de production. Les `devDependencies`, le code source TypeScript, les outils de build -- tout cela est du poids mort qui augmente la surface d'attaque et ralentit les deploiements.
</Warning>

<Tabs>
  <Tab title="Dockerfile classique (1.2 GB)">
    ```dockerfile
    FROM node:20

    WORKDIR /app

    # Copie TOUT
    COPY package*.json ./
    RUN npm install          # deps dev + prod

    COPY . .
    RUN npm run build        # compile TypeScript

    # Les outils de build, le code source, les devDependencies
    # sont toujours dans l'image finale...

    EXPOSE 3000
    CMD ["node", "dist/server.js"]
    ```
  </Tab>
  <Tab title="Multi-stage (150 MB)">
    ```dockerfile
    # Stage 1 : Builder
    FROM node:20 AS builder

    WORKDIR /app

    COPY package*.json ./
    RUN npm ci

    COPY . .
    RUN npm run build

    # Stage 2 : Runtime (image finale)
    FROM node:20-alpine

    WORKDIR /app

    COPY package*.json ./
    RUN npm ci --production

    COPY --from=builder /app/dist ./dist

    USER node
    EXPOSE 3000
    CMD ["node", "dist/server.js"]
    ```
  </Tab>
</Tabs>

<Tip>
Resultat : **1.2 GB devient 150 MB**. L'image de production ne contient que le strict necessaire pour executer l'application.
</Tip>

## Solution : multi-stage builds

Le principe est simple : utiliser **plusieurs instructions `FROM`** dans un seul Dockerfile. Chaque `FROM` demarre un nouveau **stage** avec un contexte vierge.

```
┌──────────────────────┐      ┌──────────────────────┐
│   Stage 1: builder   │      │  Stage 2: runtime     │
│                      │      │                       │
│  FROM node:20        │      │  FROM node:20-alpine  │
│                      │      │                       │
│  npm install (all)   │      │  npm ci --production  │
│  npm run build       │  ──► │  COPY --from=builder  │
│                      │      │       /app/dist       │
│  Output: /app/dist   │      │                       │
│                      │      │  Image finale: 150 MB │
│  (jete apres build)  │      │                       │
└──────────────────────┘      └──────────────────────┘
```

### Avantages

| Avantage | Description |
|---|---|
| **Image legere** | Seulement le runtime et le code compile |
| **Pas de deps dev** | `devDependencies` absentes de la production |
| **Meilleure securite** | Surface d'attaque reduite (moins de binaires, moins de libs) |
| **Deploiement rapide** | Push/pull plus rapides sur le registry |
| **Separation des responsabilites** | Build et runtime clairement isoles |

## Decortiquer le multi-stage

Analysons chaque element cle du Dockerfile multi-stage :

```dockerfile
# "AS builder" nomme le stage pour y faire reference plus tard
FROM node:20 AS builder

WORKDIR /app

# On installe TOUTES les deps (dev incluses) pour le build
COPY package*.json ./
RUN npm ci

# On copie le code source et on build
COPY . .
RUN npm run build
# A ce stade : /app/dist contient le JavaScript compile

# ------- Nouveau stage : image finale -------

# Image Alpine = legere (~120 MB vs ~900 MB)
FROM node:20-alpine

WORKDIR /app

# Deps de PRODUCTION uniquement
COPY package*.json ./
RUN npm ci --production

# COPY --from=builder : copier depuis le stage "builder"
# On ne prend QUE le dossier dist (le build final)
COPY --from=builder /app/dist ./dist

# Securite : ne pas tourner en root
USER node

EXPOSE 3000
CMD ["node", "dist/server.js"]
```

<Note>
`npm ci` est prefere a `npm install` dans les Dockerfiles. Il installe les dependances exactes du `package-lock.json`, est plus rapide et garantit la reproductibilite du build.
</Note>

### Les points cles

| Element | Role |
|---|---|
| `AS builder` | Nomme le stage pour le referencer dans `COPY --from=` |
| `COPY --from=builder` | Copie des fichiers depuis un stage precedent |
| `npm ci --production` | Installe uniquement les dependances de production |
| `USER node` | Execute le processus en tant qu'utilisateur non-root |
| `node:20-alpine` | Image de base minimale pour le runtime |

## Choix de l'image de base

Le choix de l'image de base a un impact direct sur la taille finale.

| Image | Taille | Cas d'usage |
|---|---|---|
| `node:20` | ~900 MB | Build stage, developpement local |
| `node:20-slim` | ~200 MB | Production simple, quand Alpine pose des problemes de compatibilite |
| `node:20-alpine` | ~120 MB | Production optimisee (recommande) |
| `node:20-alpine3.19` | ~120 MB | Production avec version Alpine fixee |

<Warning>
Alpine utilise **musl** au lieu de **glibc**. Certains packages natifs (bcrypt, sharp, canvas) peuvent necessiter une compilation specifique. Si vous rencontrez des problemes, utilisez `node:20-slim` comme alternative.
</Warning>

## Exemples par technologie

<Tabs>
  <Tab title="TypeScript / Node.js">
    **Image finale : ~150 MB**

    ```dockerfile
    # Build
    FROM node:20 AS builder
    WORKDIR /app
    COPY package*.json ./
    RUN npm ci
    COPY tsconfig.json ./
    COPY src ./src
    RUN npm run build

    # Runtime
    FROM node:20-alpine
    WORKDIR /app
    COPY package*.json ./
    RUN npm ci --production && npm cache clean --force
    COPY --from=builder /app/dist ./dist
    USER node
    EXPOSE 3000
    CMD ["node", "dist/server.js"]
    ```
  </Tab>
  <Tab title="Go">
    **Image finale : ~15 MB** (binaire statique)

    ```dockerfile
    # Build
    FROM golang:1.22 AS builder
    WORKDIR /app
    COPY go.mod go.sum ./
    RUN go mod download
    COPY . .
    # CGO_ENABLED=0 : binaire statique sans dependance C
    RUN CGO_ENABLED=0 GOOS=linux go build -o /app/server ./cmd/server

    # Runtime : scratch = image VIDE (0 MB)
    FROM scratch
    COPY --from=builder /app/server /server
    COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
    EXPOSE 8080
    ENTRYPOINT ["/server"]
    ```

    <Tip>
    Go produit un **binaire statique** : pas besoin de runtime, pas besoin d'OS. L'image `scratch` (vide) suffit. C'est la solution la plus legere possible.
    </Tip>
  </Tab>
  <Tab title="Frontend React">
    **Image finale : ~50 MB** (fichiers statiques servis par Nginx)

    ```dockerfile
    # Build
    FROM node:20 AS builder
    WORKDIR /app
    COPY package*.json ./
    RUN npm ci
    COPY . .
    RUN npm run build
    # Output : /app/dist (fichiers HTML/CSS/JS statiques)

    # Runtime : Nginx pour servir les fichiers statiques
    FROM nginx:alpine
    COPY --from=builder /app/dist /usr/share/nginx/html
    COPY nginx.conf /etc/nginx/conf.d/default.conf
    EXPOSE 80
    CMD ["nginx", "-g", "daemon off;"]
    ```

    <Note>
    Pour un frontend, le stage de build produit des fichiers statiques (HTML, CSS, JS). Pas besoin de Node.js en production : **Nginx Alpine** suffit pour les servir.
    </Note>
  </Tab>
</Tabs>

## Plusieurs stages de build

Pour des projets complexes, on peut enchainer plusieurs stages specialises :

```dockerfile
# Stage 1 : Dependances
FROM node:20 AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci

# Stage 2 : Build de l'application
FROM deps AS builder
COPY tsconfig.json ./
COPY src ./src
RUN npm run build

# Stage 3 : Build des assets (CSS, images)
FROM node:20 AS assets
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY postcss.config.js tailwind.config.js ./
COPY src/styles ./src/styles
RUN npm run build:css

# Stage 4 : Runtime (image finale)
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --production
COPY --from=builder /app/dist ./dist
COPY --from=assets /app/public/css ./public/css
USER node
EXPOSE 3000
CMD ["node", "dist/server.js"]
```

## Dependances entre stages

Docker est intelligent dans sa gestion des stages.

```
  deps ──────► builder ──────► runtime (image finale)
                                  │
  assets ─────────────────────────┘
```

<Steps>
  <Step title="Docker analyse le graphe de dependances">
    Les instructions `FROM <stage>` et `COPY --from=<stage>` creent des liens de dependance entre les stages. Docker construit un graphe dirige.
  </Step>
  <Step title="Seuls les stages necessaires sont executes">
    Si un stage n'est reference ni par `FROM` ni par `COPY --from=`, et qu'il n'est pas le dernier stage, Docker l'ignore completement.
  </Step>
  <Step title="Les stages peuvent heriter d'autres stages">
    `FROM deps AS builder` cree le stage `builder` a partir du stage `deps`. Le stage `builder` herite de tout le filesystem de `deps`.
  </Step>
</Steps>

## Builder un stage specifique : `--target`

Par defaut, Docker construit le **dernier stage** du Dockerfile. L'option `--target` permet de cibler un stage specifique.

```bash
# Builder uniquement le stage "builder" (utile pour debug)
docker build --target builder -t mon-app:builder .

# Builder le stage "development"
docker build --target development -t mon-app:dev .

# Builder le stage final (comportement par defaut)
docker build -t mon-app:latest .
```

### Cas d'usage de `--target`

| Commande | Utilite |
|---|---|
| `--target builder` | Debugger le build, verifier les artefacts |
| `--target development` | Image de dev avec hot-reload et outils de debug |
| `--target test` | Image contenant les outils de test |
| (defaut, dernier stage) | Image de production optimisee |

## Multi-stage : mode dev vs prod

Un seul Dockerfile pour tous les environnements :

```dockerfile
# Stage 1 : Base commune
FROM node:20 AS base
WORKDIR /app
COPY package*.json ./

# Stage 2 : Developpement (avec hot-reload)
FROM base AS development
RUN npm install
COPY . .
# nodemon pour le hot-reload
CMD ["npx", "nodemon", "--watch", "src", "--ext", "ts", "--exec", "npx ts-node src/server.ts"]

# Stage 3 : Builder
FROM base AS builder
RUN npm ci
COPY . .
RUN npm run build

# Stage 4 : Production
FROM node:20-alpine AS production
WORKDIR /app
COPY package*.json ./
RUN npm ci --production && npm cache clean --force
COPY --from=builder /app/dist ./dist
USER node
EXPOSE 3000
CMD ["node", "dist/server.js"]
```

### Utilisation avec Docker Compose

```yaml
services:
  app:
    build:
      context: .
      # Changer le target selon l'environnement
      target: development
    volumes:
      - ./src:/app/src    # hot-reload en dev
    ports:
      - "3000:3000"
```

<Tabs>
  <Tab title="docker-compose.dev.yml">
    ```yaml
    services:
      app:
        build:
          context: .
          target: development
        volumes:
          - ./src:/app/src
          - /app/node_modules  # ne pas ecraser node_modules
        ports:
          - "3000:3000"
        environment:
          - NODE_ENV=development
    ```
  </Tab>
  <Tab title="docker-compose.prod.yml">
    ```yaml
    services:
      app:
        build:
          context: .
          target: production
        ports:
          - "3000:3000"
        environment:
          - NODE_ENV=production
        restart: unless-stopped
        deploy:
          resources:
            limits:
              memory: 512M
    ```
  </Tab>
</Tabs>

## Cache multi-stage

Le cache de layers Docker est partage entre les stages. L'ordre des instructions est **crucial** pour maximiser le cache.

```dockerfile
# BON : package.json AVANT le code source
# Si le code change mais pas les deps, npm ci est en cache

FROM node:20 AS builder
WORKDIR /app

COPY package*.json ./      # Layer 1 : change rarement
RUN npm ci                  # Layer 2 : en cache si package.json inchange

COPY . .                    # Layer 3 : change souvent
RUN npm run build           # Layer 4 : rebuild a chaque changement de code
```

```dockerfile
# MAUVAIS : tout copier d'un coup
# Le moindre changement de code invalide le cache de npm ci

FROM node:20 AS builder
WORKDIR /app

COPY . .                    # Change a chaque modification
RUN npm ci                  # Reinstalle TOUT a chaque fois
RUN npm run build
```

<Tip>
Lors du build, Docker affiche `CACHED` a cote des layers qui utilisent le cache. Si vous voyez que `npm ci` se relance a chaque build alors que les deps n'ont pas change, verifiez l'ordre de vos instructions `COPY`.
</Tip>

```bash
# Observer le cache dans l'output du build
docker build -t mon-app .

# Output attendu :
# [2/5] COPY package*.json ./
# [3/5] RUN npm ci                        # CACHED
# [4/5] COPY . .
# [5/5] RUN npm run build
```

## Bonnes pratiques

### A faire

- Utiliser **Alpine** comme image de base pour le runtime
- **Copier uniquement** les fichiers necessaires (`dist`, pas tout `/app`)
- Installer les **deps de production only** (`npm ci --production`)
- Executer en tant que **`USER node`** (jamais root)
- **Nommer** chaque stage (`AS builder`, `AS deps`, `AS production`)
- Nettoyer le cache npm (`npm cache clean --force`)
- **Copier `package.json` avant le code source** pour optimiser le cache

### A eviter

- Copier **tout `node_modules`** du builder vers le runtime
- Laisser les **`devDependencies`** dans l'image de production
- Executer en **root** en production
- Oublier le fichier **`.dockerignore`**
- Utiliser `npm install` au lieu de `npm ci`
- Copier le code source TypeScript dans l'image finale

## `.dockerignore` essentiel

Le `.dockerignore` empeche l'envoi de fichiers inutiles au daemon Docker. Sans lui, le contexte de build est inutilement lourd.

```dockerignore
# Dependances (reinstallees dans le conteneur)
node_modules

# Artefacts de build (rebuildes dans le conteneur)
dist
build
.next

# Controle de version
.git
.gitignore

# Environnement et secrets
.env
.env.*

# Tests et couverture
coverage
__tests__
*.test.ts
*.spec.ts

# IDE et editeur
.vscode
.idea
*.swp
*.swo

# Documentation
*.md
LICENSE

# OS
.DS_Store
Thumbs.db

# Docker (eviter la recursion)
Dockerfile
docker-compose*.yml
.dockerignore
```

<Warning>
Sans `.dockerignore`, Docker envoie **tout** le repertoire au daemon avant le build -- y compris `node_modules` (souvent 500+ MB), `.git`, et potentiellement des fichiers `.env` contenant des secrets.
</Warning>

## Comparaison avant / apres

| Critere | Sans multi-stage | Avec multi-stage |
|---|---|---|
| **Taille de l'image** | ~1.2 GB | ~150 MB |
| **Dependances** | Dev + Prod | Prod uniquement |
| **Outils de build** | Presents (tsc, webpack...) | Absents |
| **Code source (TS)** | Present | Absent |
| **Surface d'attaque** | Elevee (nombreux binaires) | Reduite (strict minimum) |
| **Temps de pull** | ~5 min | ~30 sec |
| **Utilisateur** | root (souvent) | node (non-root) |
| **Cout de stockage** | Eleve | Reduit de ~87% |

<Note>
En production, le multi-stage build n'est pas une optimisation optionnelle -- c'est une **obligation**. Il n'y a aucune raison valable de deployer une image de 1.2 GB quand 150 MB suffisent.
</Note>

## Resume

Le multi-stage build est la technique fondamentale pour produire des images Docker de production. Il separe la phase de build (lourde) de la phase de runtime (legere), en ne gardant que le strict necessaire dans l'image finale.

```dockerfile
# Le pattern a retenir :
FROM node:20 AS builder       # 1. Builder avec tous les outils
# ... install + build

FROM node:20-alpine           # 2. Runtime leger
# ... deps prod only
COPY --from=builder /app/dist # 3. Copier uniquement le build
USER node                     # 4. Non-root
CMD ["node", "dist/server.js"]
```
